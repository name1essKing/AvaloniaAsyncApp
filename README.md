Приложение демонстрирует отличие синхронных методов и асинхронных, как они влияют на UI при наличии долгих операций.

-Четыре различных подхода к выполнению долгих операций.
-Визуальная демонстрация блокировки UI-потока.
-Автоматическая блокировка кнопок во время выполнения асинхронных команд.
-Прогресс-бары для отслеживания выполнения каждой операции.
Чистая архитектура с использованием MVVM и ReactiveUI.

Технологии
.NET 8.0
Avalonia UI - кросс-платформенный UI-фреймворк
ReactiveUI - фреймворк для реактивного программирования
MVVM Pattern - Model-View-ViewModel
Autofac - DI-контейнер (в основном проекте)

Демонстрируемые подходы
1. Синхронный метод (Проблемный)
-Использует Thread.Sleep() в UI-потоке.
-Полностью блокирует интерфейс на 3 секунды.
-Прогресс-бар обновляется только после завершения.
-Кнопка не блокируется - можно создавать множественные вызовы.

2. Фейковый Async (Антипаттерн)
-Метод объявлен как async, но не использует await.
-Thread.Sleep() всё равно блокирует UI-поток.
-Демонстрирует распространённую ошибку начинающих разработчиков.
-Наличие async не делает код автоматически асинхронным.

3. CPU-bound операция (Правильный подход). Используется для сложных вычислительных процессов. 
-Использует Task.Run() для выноса вычислений в фоновый поток.
-UI-поток остаётся свободным и отзывчивым.
-Кнопка автоматически блокируется на время выполнения.

4. I/O-bound операция (Идеальный подход)
-Использует await Task.Delay() для асинхронного ожидания
-UI-поток освобождается на время выполнения операции
-Не создаёт лишних потоков (в отличие от CPU-bound)
-Идеально для операций ввода-вывода: работа с файлами, сетевые запросы, БД








<img width="596" height="358" alt="image" src="https://github.com/user-attachments/assets/16b6ca77-0ef8-46d0-8311-ef7bece3719d" />
